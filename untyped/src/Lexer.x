-- Specification for a lexical analyzer for the untyped lambda-calculus, to be 
-- generated by the Alex lexical-analyzer-generator.

-- Haskell code copied verbatim into the top of the output lexer
{
-- any language pragmas
module Lexer 
    ( Alex
    , AlexPosn (..)
    , alexGetInput
    , alexError
    , runAlex
    , alexMonadScan
    , Range (..)
    , RangedToken (..)
    , Token (..)
    , scanMany --todo temporary
    ) where

import Data.ByteString.Lazy.Char8 (ByteString)
import qualified Data.ByteString.Lazy.Char8 as BS
}

-- Alex settings
%wrapper "monadUserState-bytestring"

-- Macros
-- char set macros
$digit = [0-9]
$alpha = [a-zA-Z] --todo: unicode

-- reg ex macros
@ident = ($alpha | \_) ($alpha | \_ | \' | \-)*

-- Begin lexer rules section
untyped :-

-- Everywhere: Skip whitespace
$white+ ;

@id { tokId }

-- End rules; More Haskell code copied verbatim, supporting functions and types
{

{- 
    With wrapper monadUserState-bytestring, the default generated signature for
    each semantic action is:
    
    -- the Int64 is the length (bytes) of the input
    type AlexAction result = AlexInput -> Int64 -> Alex result
    
    type AlexInput = 
        ( AlexPosn    -- current position,
        , Char        -- previous char
        , ByteString  -- current input string
        , Int64       -- bytes consumed so far
        )
-}

-- Type representing all the state the lexer monad carries along
data AlexUserState = AlexUserState 
    {
    }

-- value representing the initial state of the AlexUserState
alexInitUserState :: AlexUserState
alexInitUserState = AlexUserState

-- function Alex uses for construction of a RangedToken representing the EOF
alexEOF :: Alex RangedToken
alexEOF = do
    (pos, _, _, _) <- alexGetInput
    pure RangedToken {rtToken = EOF, rtRange = (Range pos pos)}

data Range = Range 
    { start :: AlexPosn
    , stop :: AlexPosn
    } deriving (Eq, Show)

data RangedToken = RangedToken 
    { rtToken :: Token
    , rtRange :: Range
    } deriving (Eq, Show)

data Token
    = Identifier ByteString
    | Lambda -- \
    | Dot -- .
    | LPar -- (
    | RPar -- )
    | EOF
    deriving (Eq, Show)

-- advance the lexer and make a Range for the corresponding movement
mkRange :: AlexInput -> Int64 -> Range
mkRange (start, _, str, _) len = Range {start = start, stop = stop}
    where stop = BS.foldl' alexMove start $ BS.take len str

-- Lex an identifier.
tokId :: AlexAction RangedToken
tokId inp@(_, _, str, _) len = pure RangedToken
    { rtToken = Identifier $ BS.take len str
    , rtRange = mkRange inp len
    }

-- Temp: a small function for testing
scanMany :: ByteString -> Either String [RangedToken]
scanMany input = runAlex input go
    where go = do
        output <- alexMonadScan
        if rtToken output == EOF 
            then pure [output] 
            else (output :) <$> go

}
